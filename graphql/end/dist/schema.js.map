{"version":3,"sources":["../src/schema.js"],"names":["context","typeDefs","resolvers","Query","moviesByTitle","root","args","session","driver","query","run","then","result","records","map","record","get","properties","movieById","console","log","Movie","genres","movie","_","params","movieId","similar","schema","headers","secrets","NEO4J_URI","auth","basic","NEO4J_USER","NEO4J_PASSWORD"],"mappings":"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","file":"schema.js","sourcesContent":["// GRAND Stack workshop - begin state\n\n// The goal of this section of the workshop is to complete our GraphQL server\n// We start with a\n// We need to query our Neo4j Database to ensure that we're\n\n// Welcome to Launchpad!\n// Log in to edit and save pads, run queries in GraphiQL on the right.\n\n// graphql-tools combines a schema string with resolvers.\nimport { makeExecutableSchema } from 'graphql-tools';\nimport { v1 as neo4j } from 'neo4j-driver';\n\n// Construct a schema, using GraphQL schema language\nconst typeDefs = `\n  type Movie {\n  movieId: ID!\n  title: String\n  year: Int\n  plot: String\n  poster: String\n  imdbRating: Float\n  genres: [String]\n  similar(first: Int=3, offset:Int=0): [Movie]\n}\n\ntype Query {\n  moviesByTitle(subString: String!, first: Int=3, offset: Int=0): [Movie]\n  movieById(subString: String!):[Movie]\n}\n`;\n\n// Provide resolver functions for your schema fields\nconst resolvers = {\n  Query: {\n    moviesByTitle: (root, args, context) => {\n      let session = context.driver.session();\n      let query =\n        'MATCH (movie:Movie) WHERE movie.title CONTAINS $subString RETURN movie LIMIT $first;';\n      return session.run(query, args).then(result => {\n        return result.records.map(record => {\n          return record.get('movie').properties;\n        });\n      });\n    },\n    movieById: (root, args, context) => {\n      console.log('movieById', args);\n      let session = context.driver.session();\n      let query = 'MATCH (movie:Movie) WHERE movie.movieId = $subString RETURN movie;';\n      return session\n        .run(query, args)\n\n        .then(result => {\n          console.log('session');\n          return result.records.map(record => {\n            return record.get('movie').properties;\n          });\n        });\n    }\n  },\n  Movie: {\n    genres: (movie, _, context) => {\n      let session = context.driver.session();\n      let params = { movieId: movie.movieId };\n      let query = `\n\t\t\t\tMATCH(m:Movie)-[:IN_GENRE]->(g:Genre)\n\t\t\t\tWHERE m.movieId = $movieId\n \t\t\t\tRETURN g.name AS genre\n\t\t\t`;\n\n      return session.run(query, params).then(result => {\n        return result.records.map(record => {\n          return record.get('genre');\n        });\n      });\n    },\n    similar: (movie, _, context) => {\n      let session = context.driver.session();\n      let params = { movieId: movie.movieId };\n      let query = `\n\t\t\t\tMATCH (m:Movie) WHERE m.movieId = $movieId\n        MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(movie:Movie)\n        WITH m, movie, COUNT(*) AS genreOverlap\n        MATCH (m)<-[:RATED]-(:User)-[:RATED]->(movie:Movie)\n        WITH movie,genreOverlap, COUNT(*) AS userRatedScore\n        RETURN movie ORDER BY (0.9 * genreOverlap) + (0.1 * userRatedScore)  DESC LIMIT 3\n\t\t\t`;\n\n      return session.run(query, params).then(result => {\n        return result.records.map(record => {\n          return record.get('movie').properties;\n        });\n      });\n    }\n  }\n};\n\n// Required: Export the GraphQL.js schema object as \"schema\"\nexport const schema = makeExecutableSchema({\n  typeDefs,\n  resolvers\n});\n\n// Optional: Export a function to get context from the request. It accepts two\n// parameters - headers (lowercased http headers) and secrets (secrets defined\n// in secrets section). It must return an object (or a promise resolving to it).\nlet driver;\n\nexport function context(headers, secrets) {\n  if (!driver) {\n    driver = neo4j.driver(\n      secrets.NEO4J_URI || 'bolt://localhost:7687',\n      neo4j.auth.basic(secrets.NEO4J_USER || 'neo4j', secrets.NEO4J_PASSWORD || 'letmein')\n    );\n  }\n  return {\n    driver\n  };\n}\n\n// Optional: Export a root value to be passed during execution\n// export const rootValue = {};\n\n// Optional: Export a root function, that returns root to be passed\n// during execution, accepting headers and secrets. It can return a\n// promise. rootFunction takes precedence over rootValue.\n// export function rootFunction(headers, secrets) {\n//   return {\n//     headers,\n//     secrets,\n//   };\n// };\n"]}